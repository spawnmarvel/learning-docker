# Docker volume

With the previous experiment, you saw that each container starts from the image definition each time it starts. While containers can create, update, and delete files, those changes are lost when you remove the container and Docker isolates all changes to that container. 

With volumes, you can change all of this.

Volumes provide the ability to connect specific filesystem paths of the container back to the host machine. 

If you mount a directory in the container, changes in that directory are also seen on the host machine. 

If you mount that same directory across container restarts, you'd see the same files.

There are two main types of volumes. You'll eventually use both, but you'll start with volume mounts.

https://docs.docker.com/storage/volumes/

## Volumes (preferred mechanism for persisting data)

Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. 

While bind mounts are dependent on the directory structure and OS of the host machine, volumes are completely managed by Docker. 

Volumes have several advantages over bind mounts:

* Volumes are easier to back up or migrate than bind mounts.
* You can manage volumes using Docker CLI commands or the Docker API.
* Volumes work on both Linux and Windows containers.
* Volumes can be more safely shared among multiple containers.
* Volume drivers let you store volumes on remote hosts or cloud providers, encrypt the contents of volumes, or add other functionality.
* New volumes can have their content pre-populated by a container.
* Volumes on Docker Desktop have much higher performance than bind mounts from Mac and Windows hosts.

* In addition, volumes are often a better choice than persisting data in a container's writable layer:
* Because a volume doesn't increase the size of the containers using it, and the volume's contents exist outside the lifecycle of a given container.

## Choose the -v or --mount flag

If you need to specify volume driver options, you must use --mount.

* -v or --volume: Consists of three fields, separated by colon characters (:). The fields must be in the correct order, and the meaning of each field isn't immediately obvious.

1. the first field is the name of the volume, (For anonymous volumes, the first field is omitted)
2. The second field is the path where the file or directory are mounted in the container.
3. The third field is optional, and is a comma-separated list of options, such as ro. These options are discussed below.
* type = bind/volume/tmpfs
* source = of the mount (source, src)
* destination = file/dir in container (destination, dst, target)
* readonly
* volume-opt = takes a key-value pair consisting of the option name and its value.

```bash
docker volume create todo-db

docker run -dp 192.168.3.4:3000:3000 --mount type=volume,src=todo-db,target=/etc/todos getting-started

```

## The todo-app

```bash
# Create a volume by using the docker volume create command.
docker volume create todo-db

# view it
docker volume ls


# Start the todo app container, but add the --mount option to specify a volume mount. 
# Give the volume a name, and mount it to /etc/todos in the container, which captures all files created at the path
# By default, the todo app stores its data in a SQLite database at /etc/todos/todo.db in the container's filesystem.
docker run -dp 192.168.3.4:3000:3000 --mount type=volume,src=todo-db,target=/etc/todos getting-started

docker volume inspect todo-db

[
    {
        "CreatedAt": "2023-12-29T17:06:14Z",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/todo-db/_data",
        "Name": "todo-db",
        "Options": null,
        "Scope": "local"
    }
]

# The Mountpoint is the actual location of the data on the disk. 
# Note that on most machines, you will need to have root access to access this directory from the host.

sudo su -

cd

pwd
# /var/lib/docker/volumes/todo-db/_data


```

## Example RabbitMQ

https://hub.docker.com/_/rabbitmq

One of the important things to note about RabbitMQ is that it stores data based on what it calls the "Node Name", which defaults to the hostname. 

What this means for usage in Docker is that we should specify -h/--hostname explicitly for each daemon so that we don't get a random hostname and can keep track of our data:

```bash

docker run -d --hostname rmq1 --name rabbitmq1 -p 15672:15672 rabbitmq:3.12-management

docker ps
# 5c0573e2ec4b   rabbitmq:3.12-management   "docker-entrypoint.s…"   3 minutes ago   Up 3 minutes    4369/tcp, 5671-5672/tcp, 15671/tcp, 15691-15692/tcp, 25672/tcp, 0.0.0.0:15672->15672/tcp, :::15672->15672/tcp   rabbitmq1

docker logs rabbitmq1

# CONTAINER ID   IMAGE             COMMAND                  CREATED          STATUS          PORTS                                                 NAMES
# e804151fa8e8   rabbitmq:3        "docker-entrypoint.s…"   4 minutes ago    Up 4 minutes    4369/tcp, 5671-5672/tcp, 15691-15692/tcp, 25672/tcp   rabbitmq1


docker inspect rabbitmq1

 "Mounts": [
            {
                "Type": "volume",
                "Name": "aabbf59933f0e27eaf7fa44b3e588989beb32b3be3c9f97afaa85e4e1ba2f91f",
                "Source": "/var/lib/docker/volumes/aabbf59933f0e27eaf7fa44b3e588989beb32b3be3c9f97afaa85e4e1ba2f91f/_data",
                "Destination": "/var/lib/rabbitmq",

 "Image": "rabbitmq:3.12-management",
            "Volumes": {
                "/var/lib/rabbitmq": {}

# Note the database dir there, especially that it has my "Node Name" appended to the end for the file storage. 
# This image makes all of /var/lib/rabbitmq a volume by default.

# to enter /var/lib/docker
sudo su -
```


Visit http://public-ip:15672
Open nsg, succcess


**Make a queue45 and stop/start container**

```bash
# add queue45

docker stop rabbitmq1

docker start rabbitmq1

# visit http://public-ip:15672
# and queue45 is there

# 2023-12-29 23:40:22.195295+00:00 [info] <0.426.0> Recovering 1 queues of type rabbit_classic_queue took 19ms

```
**Add msg to the queue45 and stop/start container**

```bash
# 1 msg to queue45
# Remember to use Delivery-mode 2 - Persisten, args

docker stop rabbitmq1

docker start rabbitmq1

# visit http://public-ip:15672
# and queue45 is there with 1 msg

```

![Delivery mode 2 ](https://github.com/spawnmarvel/learning-docker/blob/main/images/deliverymode.jpg)

## Create volume

```bash
# remove all before you start
# docker ps
# docker ps -
# docker rm -f rabbitmq1
# docker images
# docker rmi -f rabbitmq1
# docker volume ps
# docker volume prune
# docker volume rm rabbitmq_data
# or rename all below to xxx2

docker volume create rabbitmq_data

docker volume ls

docker run -d --hostname rmq2 --name rabbitmq2 -p 15672:15672 -p 5672:5672 --mount type=volume,src=rabbitmq_data,target=/var/lib/rabbitmq rabbitmq:3.12-management

docker inspect rabbitmq2

 "Mounts": [
            {
                "Type": "volume",
                "Name": "rabbitmq_data",
                "Source": "/var/lib/docker/volumes/rabbitmq_data/_data",
                "Destination": "/var/lib/rabbitmq",

  "Image": "rabbitmq:3.12-management",
            "Volumes": {
                "/var/lib/rabbitmq": {}              


cd
# /var/lib/docker/volumes/rabbitmq_data/_data
ls
# mnesia
cd
# rabbit@rmq2  rabbit@rmq2-feature_flags  rabbit@rmq2-plugins-expand  rabbit@rmq2.pid

```
**Make a queue852 and stop/start container**

```bash
docker restart rabbitmq2

```

**Add some messages to queue852**

```bash
# add 3 msg to queue852
# Remember to use Delivery-mode 2 - Persisten, args

docker restart rabbitmq2

# 3 msg to queue852, success
```

![Volume persisten ](https://github.com/spawnmarvel/learning-docker/blob/main/images/volume_persisten.jpg)
