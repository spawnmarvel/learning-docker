# Docker volume

With the previous experiment, you saw that each container starts from the image definition each time it starts. While containers can create, update, and delete files, those changes are lost when you remove the container and Docker isolates all changes to that container. 

With volumes, you can change all of this.

Volumes provide the ability to connect specific filesystem paths of the container back to the host machine. 

If you mount a directory in the container, changes in that directory are also seen on the host machine. 

If you mount that same directory across container restarts, you'd see the same files.

There are two main types of volumes. You'll eventually use both, but you'll start with volume mounts.

https://docs.docker.com/storage/volumes/

## Docker Volumes explained in 6 minutes

3 Types

```bash

# Host volumes
# host:container
docker run -v /home/mount/data:/var/lib/mysql

# Anonymous volumes, docker fixes it
# anonymous container
docker run -v /var/lib/mysql

# Named volumes, use in production
# /var/lib/docker/volumes/hash/_data/name:container
docker run -v name:/var/lib/mysql
```

Example docker compose

```yml
version: '3'

services:
  rmq-app:
    build:
      context: .
      dockerfile: Dockerfile
    hostname: rmq4.cloud
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 500m
    ports:
      - 5672:5672
      - 15672:15672
    networks:
      - net_messaging
    volumes:
      - vol_rabbitmq_data:/var/lib/rabbitmq
      
networks:
  net_messaging:

volumes:
  vol_rabbitmq_data:

```

https://www.youtube.com/watch?v=p2PH_YPCsis&list=LL&index=1

## Volumes (preferred mechanism for persisting data)

Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. 

While bind mounts are dependent on the directory structure and OS of the host machine, volumes are completely managed by Docker. 

Volumes have several advantages over bind mounts:

* Volumes are easier to back up or migrate than bind mounts.
* You can manage volumes using Docker CLI commands or the Docker API.
* Volumes work on both Linux and Windows containers.
* Volumes can be more safely shared among multiple containers.
* Volume drivers let you store volumes on remote hosts or cloud providers, encrypt the contents of volumes, or add other functionality.
* New volumes can have their content pre-populated by a container.
* Volumes on Docker Desktop have much higher performance than bind mounts from Mac and Windows hosts.

* In addition, volumes are often a better choice than persisting data in a container's writable layer:
* Because a volume doesn't increase the size of the containers using it, and the volume's contents exist outside the lifecycle of a given container.

## Choose the -v or --mount flag

If you need to specify volume driver options, you must use --mount.

* -v or --volume: Consists of three fields, separated by colon characters (:). The fields must be in the correct order, and the meaning of each field isn't immediately obvious.

1. the first field is the name of the volume, (For anonymous volumes, the first field is omitted)
2. The second field is the path where the file or directory are mounted in the container.
3. The third field is optional, and is a comma-separated list of options, such as ro. These options are discussed below.
* type = bind/volume/tmpfs
* source = of the mount (source, src)
* destination = file/dir in container (destination, dst, target)
* readonly
* volume-opt = takes a key-value pair consisting of the option name and its value.

```bash
docker volume create todo-db

docker run -dp 192.168.3.4:3000:3000 --mount type=volume,src=todo-db,target=/etc/todos getting-started

```

## The todo-app

```bash
# Create a volume by using the docker volume create command.
docker volume create todo-db

# view it
docker volume ls


# Start the todo app container, but add the --mount option to specify a volume mount. 
# Give the volume a name, and mount it to /etc/todos in the container, which captures all files created at the path
# By default, the todo app stores its data in a SQLite database at /etc/todos/todo.db in the container's filesystem.
docker run -dp 192.168.3.4:3000:3000 --mount type=volume,src=todo-db,target=/etc/todos getting-started

docker volume inspect todo-db

[
    {
        "CreatedAt": "2023-12-29T17:06:14Z",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/todo-db/_data",
        "Name": "todo-db",
        "Options": null,
        "Scope": "local"
    }
]

# The Mountpoint is the actual location of the data on the disk. 
# Note that on most machines, you will need to have root access to access this directory from the host.

sudo su -

cd

pwd
# /var/lib/docker/volumes/todo-db/_data


```

## Example RabbitMQ

https://hub.docker.com/_/rabbitmq

One of the important things to note about RabbitMQ is that it stores data based on what it calls the "Node Name", which defaults to the hostname. 

What this means for usage in Docker is that we should specify -h/--hostname explicitly for each daemon so that we don't get a random hostname and can keep track of our data:

```bash

docker run -d --hostname rmq1 --name rabbitmq1 -p 15672:15672 rabbitmq:3.12-management

docker ps
# 5c0573e2ec4b   rabbitmq:3.12-management   "docker-entrypoint.s…"   3 minutes ago   Up 3 minutes    4369/tcp, 5671-5672/tcp, 15671/tcp, 15691-15692/tcp, 25672/tcp, 0.0.0.0:15672->15672/tcp, :::15672->15672/tcp   rabbitmq1

docker logs rabbitmq1

# CONTAINER ID   IMAGE             COMMAND                  CREATED          STATUS          PORTS                                                 NAMES
# e804151fa8e8   rabbitmq:3        "docker-entrypoint.s…"   4 minutes ago    Up 4 minutes    4369/tcp, 5671-5672/tcp, 15691-15692/tcp, 25672/tcp   rabbitmq1


docker inspect rabbitmq1

 "Mounts": [
            {
                "Type": "volume",
                "Name": "aabbf59933f0e27eaf7fa44b3e588989beb32b3be3c9f97afaa85e4e1ba2f91f",
                "Source": "/var/lib/docker/volumes/aabbf59933f0e27eaf7fa44b3e588989beb32b3be3c9f97afaa85e4e1ba2f91f/_data",
                "Destination": "/var/lib/rabbitmq",

 "Image": "rabbitmq:3.12-management",
            "Volumes": {
                "/var/lib/rabbitmq": {}

# Note the database dir there, especially that it has my "Node Name" appended to the end for the file storage. 
# This image makes all of /var/lib/rabbitmq a volume by default.

# to enter /var/lib/docker
sudo su -
```


Visit http://public-ip:15672
Open nsg, succcess


**Make a queue45 and stop/start container**

```bash
# add queue45

docker stop rabbitmq1

docker start rabbitmq1

# visit http://public-ip:15672
# and queue45 is there

# 2023-12-29 23:40:22.195295+00:00 [info] <0.426.0> Recovering 1 queues of type rabbit_classic_queue took 19ms

```
**Add msg to the queue45 and stop/start container**

```bash
# 1 msg to queue45
# Remember to use Delivery-mode 2 - Persisten, args

docker stop rabbitmq1

docker start rabbitmq1

# visit http://public-ip:15672
# and queue45 is there with 1 msg

```

![Delivery mode 2 ](https://github.com/spawnmarvel/learning-docker/blob/main/images/deliverymode.jpg)

## Create volume

```bash
# remove all before you start
# docker ps
# docker ps -
# docker rm -f rabbitmq1
# docker images
# docker rmi -f rabbitmq1
# docker volume ps
# docker volume prune
# docker volume rm rabbitmq_data
# or rename all below to xxx2

docker volume create rabbitmq_data

docker volume ls

docker run -d --hostname rmq2 --name rabbitmq2 -p 15672:15672 -p 5672:5672 --mount type=volume,src=rabbitmq_data,target=/var/lib/rabbitmq rabbitmq:3.12-management

docker inspect rabbitmq2

 "Mounts": [
            {
                "Type": "volume",
                "Name": "rabbitmq_data",
                "Source": "/var/lib/docker/volumes/rabbitmq_data/_data",
                "Destination": "/var/lib/rabbitmq",

  "Image": "rabbitmq:3.12-management",
            "Volumes": {
                "/var/lib/rabbitmq": {}              


cd
# /var/lib/docker/volumes/rabbitmq_data/_data
ls
# mnesia
cd
# rabbit@rmq2  rabbit@rmq2-feature_flags  rabbit@rmq2-plugins-expand  rabbit@rmq2.pid

```
**Make a queue852 and stop/start container**

```bash
docker restart rabbitmq2

```

**Add some messages to queue852**

```bash
# add 3 msg to queue852
# Remember to use Delivery-mode 2 - Persisten, args

docker restart rabbitmq2

# 3 msg to queue852, success
```

![Volume persisten ](https://github.com/spawnmarvel/learning-docker/blob/main/images/volume_persistent.jpg)


## Docker volume data move

The standard data location used for docker is /var/lib/docker. Because this directory contains all containers/images/volumes, it can be large.

![Volume persistent ](https://github.com/spawnmarvel/learning-docker/blob/main/images/datadisk.jpg)

```bash
df -h
# /dev/sda1       4.0G   61M  4.0G   2% /datadrive

sudo service docker stop

# Create/Edit /etc/docker/daemon.json file:

{
   "data-root": "/path/to/new/docker/location"
}

# our path
{
   "data-root": "/datadrive"
}

sudo rsync -aP /var/lib/docker/ /datedrive

df -h
# /dev/sda1       4.0G  1.8G  2.2G  45% /datadrive

sudo rm -rf /var/lib/docker/

sudo service start docker

docker run hello-world


```

![Hello docker ](https://github.com/spawnmarvel/learning-docker/blob/main/images/hello-docker.jpg)

## Verify old containers

```bash
# check volume
docker volume ls

# [..]
# local     rabbitmq_data
# local     todo-db

# verify images
docker images

# getting-started            latest            00767b2de32f   24 hours ago   223MB
# rabbitmq                   3.12-management   2d45ce625f60   7 months ago   246MB
# hello-world                latest            d2c94e258dcb   8 months ago   13.3kB
# mariadb                    11                c74611c2858a   2 weeks ago    404MB

# verify containers
docker ps -a

# jepp all is there


# start rabbitmq2 and verify messages
docker start rabbitmq2

Error response from daemon: error evaluating symlinks from mount source "/var/lib/docker/volumes/rabbitmq_data/_data": lstat /var/lib/docker: no such file or directory
Error: failed to start containers: rabbitmq2

# it is the same for todo-app, but mariadb is running

# remove the container
docker rm -f rabbitmq1
docker rm -f rabbitmq2

# remove the volume
docker volume ls
docker volume remove -f rabbitmq_data


# create the volume
docker volume create rabbitmq_data

# create the container
docker run -d --hostname rmq2 --name rabbitmq2 -p 15672:15672 -p 5672:5672 --mount type=volume,src=rabbitmq_data,target=/var/lib/rabbitmq rabbitmq:3.12-management

docker inspect rabbitmq2


 "Mounts": [
            {
                "Type": "volume",
                "Name": "rabbitmq_data",
                "Source": "/datadrive/volumes/rabbitmq_data/_data",
                "Destination": "/var/lib/rabbitmq",

# visit http://publicip:15672
# add a queue and a message

# restart rabbitmq2
docker restart rabbitmq2
```
![Volume restart ](https://github.com/spawnmarvel/learning-docker/blob/main/images/volume_restart.jpg)

## In production must add --restart always


```bash
docker images
# REPOSITORY                 TAG               
# getting-started            latest            
# username/getting-started   latest            
# rabbitmq                   3.12-management

docker ps -a
# CONTAINER ID   IMAGE                      COMMAND                  CREATED          STATUS                    PORTS    NAMES
# 2053c0ee85ea   rabbitmq:3.12-management   "docker-entrypoint.s…"   26 hours ago     Exited (0) 26 hours ago            rabbitmq2

docker volume
# DRIVER    VOLUME NAME
# local     rabbitmq_data
# local     todo-db

# start it
docker start rabbitmq2

# visit http:/7public-ip:15672
# queue01 classic 	D 	idle    1


```
always	Always restart the container if it stops. If it's manually stopped, it's restarted only when Docker daemon restarts or the container itself is manually restarted.


https://docs.docker.com/config/containers/start-containers-automatically/