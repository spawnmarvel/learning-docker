# Docker volume

With the previous experiment, you saw that each container starts from the image definition each time it starts. While containers can create, update, and delete files, those changes are lost when you remove the container and Docker isolates all changes to that container. 

With volumes, you can change all of this.

Volumes provide the ability to connect specific filesystem paths of the container back to the host machine. 

If you mount a directory in the container, changes in that directory are also seen on the host machine. 

If you mount that same directory across container restarts, you'd see the same files.

There are two main types of volumes. You'll eventually use both, but you'll start with volume mounts.

https://docs.docker.com/storage/volumes/

## Volumes (preferred mechanism for persisting data)

Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. 

While bind mounts are dependent on the directory structure and OS of the host machine, volumes are completely managed by Docker. 

Volumes have several advantages over bind mounts:

* Volumes are easier to back up or migrate than bind mounts.
* You can manage volumes using Docker CLI commands or the Docker API.
* Volumes work on both Linux and Windows containers.
* Volumes can be more safely shared among multiple containers.
* Volume drivers let you store volumes on remote hosts or cloud providers, encrypt the contents of volumes, or add other functionality.
* New volumes can have their content pre-populated by a container.
* Volumes on Docker Desktop have much higher performance than bind mounts from Mac and Windows hosts.

* In addition, volumes are often a better choice than persisting data in a container's writable layer:
* Because a volume doesn't increase the size of the containers using it, and the volume's contents exist outside the lifecycle of a given container.

## Choose the -v or --mount flag

If you need to specify volume driver options, you must use --mount.

* -v or --volume: Consists of three fields, separated by colon characters (:). The fields must be in the correct order, and the meaning of each field isn't immediately obvious.

1. the first field is the name of the volume, (For anonymous volumes, the first field is omitted)
2. The second field is the path where the file or directory are mounted in the container.
3. The third field is optional, and is a comma-separated list of options, such as ro. These options are discussed below.
* type = bind/volume/tmpfs
* source = of the mount (source, src)
* destination = file/dir in container (destination, dst, target)
* readonly
* volume-opt = takes a key-value pair consisting of the option name and its value.

```bash
docker volume create todo-db

docker run -dp 192.168.3.4:3000:3000 --mount type=volume,src=todo-db,target=/etc/todos getting-started

```

## The todo-app

```bash
# Create a volume by using the docker volume create command.
docker volume create todo-db

# view it
docker volume ls


# Start the todo app container, but add the --mount option to specify a volume mount. 
# Give the volume a name, and mount it to /etc/todos in the container, which captures all files created at the path
# By default, the todo app stores its data in a SQLite database at /etc/todos/todo.db in the container's filesystem.
docker run -dp 192.168.3.4:3000:3000 --mount type=volume,src=todo-db,target=/etc/todos getting-started

docker volume inspect todo-db

[
    {
        "CreatedAt": "2023-12-29T17:06:14Z",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/todo-db/_data",
        "Name": "todo-db",
        "Options": null,
        "Scope": "local"
    }
]

# The Mountpoint is the actual location of the data on the disk. 
# Note that on most machines, you will need to have root access to access this directory from the host.

sudo su -

cd

pwd
# /var/lib/docker/volumes/todo-db/_data


```

## Example RabbitMQ

https://hub.docker.com/_/rabbitmq

One of the important things to note about RabbitMQ is that it stores data based on what it calls the "Node Name", which defaults to the hostname. 

What this means for usage in Docker is that we should specify -h/--hostname explicitly for each daemon so that we don't get a random hostname and can keep track of our data:

```bash

docker run -d --hostname rmq1 --name rabbitmq1 rabbitmq:3

docker ps
# e804151fa8e8   rabbitmq:3        "docker-entrypoint.s…"   45 seconds ago   Up 43 seconds   4369/tcp, 5671-5672/tcp, 15691-15692/tcp, 25672/tcp   rabbitmq16b37e306c288

docker logs e804151fa8e8

# CONTAINER ID   IMAGE             COMMAND                  CREATED          STATUS          PORTS                                                 NAMES
# e804151fa8e8   rabbitmq:3        "docker-entrypoint.s…"   4 minutes ago    Up 4 minutes    4369/tcp, 5671-5672/tcp, 15691-15692/tcp, 25672/tcp   rabbitmq1


docker inspect rabbitmq1

 "Mounts": [
            {
                "Type": "volume",
                "Name": "6f45a2401d04faec4c5dbb792f8834897eb7a55b44226cec20c3a8a8f8448dfb",
                "Source": "/var/lib/docker/volumes/6f45a2401d04faec4c5dbb792f8834897eb7a55b44226cec20c3a8a8f8448dfb/_data",
                "Destination": "/var/lib/rabbitmq",


docker logs rabbitmq1


```

logs
```logs
Starting broker...2023-12-29 17:55:47.863340+00:00 [info] <0.230.0>
2023-12-29 17:55:47.863340+00:00 [info] <0.230.0>  node           : rabbit@rmq1
2023-12-29 17:55:47.863340+00:00 [info] <0.230.0>  home dir       : /var/lib/rabbitmq
2023-12-29 17:55:47.863340+00:00 [info] <0.230.0>  config file(s) : /etc/rabbitmq/conf.d/10-defaults.conf
2023-12-29 17:55:47.863340+00:00 [info] <0.230.0>                 : /etc/rabbitmq/conf.d/20-management_agent.disable_metrics_collector.conf

```
**Enter it and enable management plugin**

```bash
docker exec -it rabbitmq1 bash

# pwd
/etc/rabbitmq/conf.d

ls
10-defaults.conf  20-management_agent.disable_metrics_collector.conf

cat 10-defaults.conf

rabbitmq-plugins list

```
